{"version":3,"sources":["webpack/bootstrap 64edd740550d2eec6e9c","./lib/entry.js","./lib/gameView.js","./lib/game.js","./lib/spaceman.js","./lib/centerShape.js","./lib/background.js","./lib/wall.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;;AAEA;AACA;;;;;;;ACHA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,IAAG;AACH;;AAEA;;;;;;;ACnBA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAoC,gBAAgB;AACpD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA,oBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;;;;;;;;ACxKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;;AAEA;;;AAGA;;AAEA;AACA;AACA,kBAAiB,0BAA0B;AAC3C;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;AAIA;;;;;;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oBAAmB,gBAAgB;AACnC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAmB,iBAAiB;AACpC;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 64edd740550d2eec6e9c\n **/","var gameView = require ('./gameView.js');\n\nvar gv = new gameView();\ngv.start();\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/entry.js\n ** module id = 0\n ** module chunks = 0\n **/","var Game = require('./game');\n\nfunction GameView() {\n  this.game = new Game();\n  this.ctx = document.getElementById(\"game-canvas\").getContext(\"2d\");\n}\n\nGameView.prototype.start = function(){\n  var time = 0;\n  setInterval(function(){\n    time += 1;\n  }, 10);\n\n  setInterval(function() {\n    this.game.step(time);\n    this.game.draw(this.ctx);\n  }.bind(this), 20);\n};\n\nmodule.exports = GameView;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/gameView.js\n ** module id = 1\n ** module chunks = 0\n **/","var CenterShape = require('./centerShape');\nvar Background = require('./background');\nvar SpaceMan = require('./spaceman');\nvar Wall = require('./wall');\n\nvar WIDTH = 800;\nvar HEIGHT = 600;\n\nfunction Game(){\n  this.time;\n  this.centerRadius = 70;\n  this.playerRadius = 90;\n  this.sides = 6;\n  this.walls = [];\n  this.backgroundShape = new Background({\n    sides: this.sides,\n    width: WIDTH,\n    height: HEIGHT,\n    radius: 600,\n    colors: [\"white\", \"lightblue\"]\n  });\n  this.centerShape = new CenterShape({\n    sides: this.sides,\n    width: WIDTH,\n    height: HEIGHT,\n    radius: this.centerRadius,\n    colors: [\"white\", \"purple\"]\n  });\n  this.spaceMan = new SpaceMan({\n    width: WIDTH,\n    height: HEIGHT,\n    radius: this.playerRadius,\n    size: 10,\n    color: 'purple',\n    sides: this.sides\n  });\n  this.rotation =  (1 * (Math.PI / 180));\n  this.bindKeyListeners();\n}\n\nGame.prototype.bindKeyListeners = function () {\n  document.addEventListener(\"keydown\", function(e){\n    if (e.keyCode === 38) {\n      this.sides += 1;\n      if (this.sides > 10){\n        this.sides = 10;\n      }\n      this.returnUpdatedObjects();\n    } else if (e.keyCode === 40) {\n      this.sides -= 1;\n      if (this.sides < 3) {\n        this.sides = 3;\n      }\n      this.returnUpdatedObjects();\n    } else if (e.keyCode === 39) {\n      this.spaceMan.leftDown = true;\n    } else if (e.keyCode === 37) {\n      this.spaceMan.rightDown = true;\n    }\n  }.bind(this));\n\n  document.addEventListener(\"keyup\", function(e){\n    if (e.keyCode === 39) {\n      this.spaceMan.leftDown = false;\n    } else if (e.keyCode === 37) {\n      this.spaceMan.rightDown = false;\n    }\n  }.bind(this));\n};\n\nGame.prototype.returnUpdatedObjects = function () {\n  this.backgroundShape.sides = this.sides;\n  this.centerShape.sides = this.sides;\n  this.spaceMan.sides = this.sides;\n};\n\nGame.prototype.draw = function (ctx) {\n  ctx.clearRect(0, 0, WIDTH, HEIGHT);\n  ctx.save();\n  ctx.translate(400, 300);\n  ctx.rotate(this.rotation);\n  this.backgroundShape.drawBackground(ctx);\n  this.walls.forEach(function(wall){wall.draw(ctx);});\n  this.spaceMan.drawSelf(ctx);\n  this.centerShape.drawCenterShape(ctx);\n  ctx.restore();\n  this.rotation += (1 * (Math.PI / 180));\n};\n\nGame.prototype.handleWalls = function (wall, index) {\n  if (wall.distance < this.centerRadius) {\n    this.walls.splice(index, 1);\n  } else {\n    wall.move();\n  }\n};\n\nGame.prototype.addWalls = function () {\n  this.lastTime;\n  if (this.time < 1000) {\n    var interval = 500;\n  } else if (1000 < this.time && this.time < 3000) {\n    interval = 250;\n  } else {\n    interval = 100;\n  }\n  if (this.time % interval === 0 && this.time !== this.lastTime) {\n    this.lastTime = this.time;\n\t\tvar maxNewWalls = 0;\n\t\tif ( this.time < 500 ) {\n      maxNewWalls = 2;\n    } else if (this.time < 1000) {\n      maxNewWalls = 3;\n    } else if (this.time < 3000) {\n      maxNewWalls = 4;\n    } else {\n      maxNewWalls = this.sides - 1;\n    }\n\n    var newWalls = Math.min(this.sides - 1, maxNewWalls);\n    var toAdd = [];\n    for (var i = 0; i < newWalls; i++){\n      toAdd.push(\n        new Wall({\n          section: Math.floor(1 + (Math.random() * (this.sides))),\n          sides: this.sides,\n          color: \"purple\"\n          })\n        );\n      }\n    this.walls = this.walls.concat(toAdd);\n    }\n\n};\n\nGame.prototype.step = function (time) {\n  this.time = time;\n  this.spaceMan.move();\n\n  this.addWalls();\n  this.walls.forEach(function(wall, index){\n    this.handleWalls(wall, index);\n  }.bind(this));\n\n  var wallsToCheck = this.getRelevantWalls();\n  this.checkForCollision(wallsToCheck);\n};\n\n\nGame.prototype.checkForCollision = function (walls) {\n  walls.forEach(function(wall){\n    if (this.playerRadius + 36 < wall.distance &&\n        wall.distance < this.playerRadius + 42 &&\n        wall.section === this.spaceMan.currentSection) {\n      alert(wall.section);\n      this.spaceMan.alive = false;\n    }\n  }.bind(this));\n};\n\nGame.prototype.getRelevantWalls = function () {\n  var currentSection = this.spaceMan.currentSection;\n  var relevantWalls = this.walls.filter(function(wall) {\n    return wall.section === currentSection;\n  });\n  return relevantWalls;\n};\n\nmodule.exports = Game;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/game.js\n ** module id = 2\n ** module chunks = 0\n **/","function SpaceMan(optionsHash) {\n  this.radius = optionsHash['radius'];\n  this.angle = (Math.PI * 2 / 6);\n  this.size = optionsHash['size'];\n  this.alive = true;\n  this.sides = optionsHash['sides'];\n  this.color = optionsHash['color'];\n  this.pos = [this.radius * Math.cos(this.angle),\n              this.radius * Math.sin(this.angle)];\n  this.sections = this.returnSections(this.sides);\n  this.currentSection = 1;\n  this.bindKeyListeners();\n}\n\nSpaceMan.prototype.returnSections = function (sides) {\n  var sections = [];\n  for (var i = 1; i <= this.sides; i++) {\n    sections.push((Math.PI * 2 / 6) * i);\n  }\n  return sections;\n};\n\nSpaceMan.prototype.bindKeyListeners = function () {\n\n\n};\n\nSpaceMan.prototype.updateSection = function (angle) {\n  var currentSection;\n  for (var i = 0; i < this.sections.length; i++) {\n    if (angle >= this.sections[i]) {\n      currentSection = i + 1;\n    } else if (angle < this.sections[0]) {\n      currentSection = 6;\n    }\n  }\n  console.log(currentSection);\n  this.currentSection = currentSection;\n};\n\n\nSpaceMan.prototype.move = function () {\n  var r = this.radius;\n  var angle = this.angle;\n\n  if (this.leftDown) {\n    angle += 8 * Math.PI / 180;\n  } else if (this.rightDown) {\n    angle -= 8 * Math.PI / 180;\n  } else {\n    return;\n  }\n\n  if (angle < 0) {\n    angle = angle + (Math.PI * 2);\n  } else {\n    angle = angle % (Math.PI * 2);\n  }\n  var newX = r * Math.cos(angle);\n  var newY = r * Math.sin(angle);\n  this.pos = [newX, newY];\n  this.angle = angle;\n\n  this.updateSection(angle);\n};\n\nSpaceMan.prototype.drawSelf = function(ctx){\n  ctx.fillStyle = this.color;\n  ctx.beginPath();\n\n  ctx.arc(\n      this.pos[0],\n      this.pos[1],\n      this.size,\n      0,\n      2 * Math.PI,\n      false\n    );\n\n    ctx.fill();\n};\n\n\n\nmodule.exports = SpaceMan;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/spaceman.js\n ** module id = 4\n ** module chunks = 0\n **/","function CenterShape(optionsHash) {\n  this.sides = optionsHash['sides'];\n  this.width = optionsHash['width'];\n  this.height = optionsHash['height'];\n  this.radius = optionsHash['radius'];\n  this.colors = optionsHash['colors'];\n  this.origin = [0, 0];\n  this.rotation = 0;\n}\n\nCenterShape.prototype.polygon =\n  function(ctx) {\n    if (this.sides < 3) {\n      this.sides = 3;\n    }\n    var angle = (Math.PI * 2)/this.sides;\n    var r = this.radius;\n\n    ctx.strokeStyle = this.colors[1];\n    ctx.fillStyle = this.colors[0];\n    ctx.lineWidth = 10;\n\n    ctx.save();\n    ctx.moveTo(r,0);\n    for (var i = 1; i < this.sides; i++) {\n      ctx.lineTo(r * Math.cos(angle * i),r * Math.sin(angle * i));\n      ctx.stroke();\n\n    }\n    ctx.closePath();\n    ctx.fill();\n    ctx.restore();\n\n};\n\nCenterShape.prototype.drawCenterShape = function (ctx) {\n  ctx.beginPath();\n  this.polygon(ctx);\n  ctx.stroke();\n};\n\nmodule.exports = CenterShape;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/centerShape.js\n ** module id = 5\n ** module chunks = 0\n **/","function Background(optionsHash) {\n  this.sides = optionsHash['sides'];\n  this.width = optionsHash['width'];\n  this.height = optionsHash['height'];\n  this.radius = optionsHash['radius'];\n  this.colors = optionsHash['colors'];\n  this.rotation = 0;\n}\n\nBackground.prototype.drawBackground =\n  function(ctx) {\n    if (this.sides < 3) {\n      this.sides = 3;\n    }\n    var angle = (Math.PI * 2)/this.sides;\n    var rotation = this.rotation + angle;\n    var w = this.width;\n    var h = this.height;\n    var r = this.radius;\n\n    for (var i = 1; i <= this.sides; i++) {\n      if (i % 2) {\n        ctx.fillStyle = this.colors[0];\n      } else {\n        ctx.fillStyle = this.colors[1];\n      }\n      var j = i + 1;\n      ctx.beginPath();\n      ctx.moveTo(0,0);\n      ctx.lineTo((Math.cos(angle*i) ) * r, (Math.sin(angle*i)) * r);\n      ctx.lineTo((Math.cos(angle*j) ) * r, (Math.sin(angle * j)) * r);\n      ctx.closePath();\n      ctx.fill();\n    }\n    this.rotation += -(Math.random() * 0.02);\n\n};\n\nmodule.exports = Background;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/background.js\n ** module id = 6\n ** module chunks = 0\n **/","function Wall(optionsHash) {\n  this.sides = optionsHash['sides'];\n  this.section = optionsHash['section'];\n  this.distance = 600;\n  this.width = 30;\n  this.collided = false;\n  this.color = optionsHash['color'];\n}\n\nWall.prototype.move = function() {\n  this.distance -= 3;\n};\n\nWall.prototype.draw = function (ctx) {\n  ctx.fillStyle = this.color;\n  var sides = this.sides;\n  var section = this.section;\n  var distance = this.distance;\n  var w = this.width;\n  var angle = (Math.PI * 2)/this.sides;\n  ctx.beginPath();\n  ctx.moveTo(Math.cos(angle * section) * distance, Math.sin(angle * section) * distance);\n  ctx.lineTo(Math.cos(angle * (section + 1)) * distance, Math.sin(angle * (section + 1)) * distance);\n  ctx.lineTo(Math.cos(angle * (section + 1)) * (distance - w), Math.sin(angle * (section + 1)) * (distance - w));\n  ctx.lineTo(Math.cos(angle * section) * (distance - w), Math.sin(angle * section) * (distance - w));\n  ctx.closePath();\n  ctx.fill();\n};\n\nmodule.exports = Wall;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/wall.js\n ** module id = 7\n ** module chunks = 0\n **/"],"sourceRoot":""}